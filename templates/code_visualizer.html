<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data structure Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.1.2/socket.io.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
        #editor { width: 100%; height: 300px; }
        #output { margin: 20px; }
        #visualization-area { margin-top: 20px; }
        .array-element { display: inline-block; margin: 5px; padding: 10px; background-color: lightblue; }
        .changed { background-color: lightcoral; }
        .array-visualization { margin: 10px; }
        .queue-element { 
            display: inline-block; 
            margin: 5px; 
            padding: 10px; 
            background-color: #ffeb3b;
            position: relative;
        }
        .queue-element::after {
            content: "→";
            position: absolute;
            right: -15px;
        }
        .queue-element:last-child::after {
            content: "";
        }
        .grid-container {
            display: inline-block;
            border: 1px solid #ccc;
            padding: 5px;
            margin: 10px;
        }
        .grid-row {
            display: flex;
        }
        .grid-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #999;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
        }
        .CodeMirror {
            height: 300px;
            border: 1px solid #ddd;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 14px;
        }
        .editor-container {
            margin: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        #output {
            margin: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            min-height: 50px;
        }
        .array-element {
            transition: all 0.3s ease;
            position: relative;
        }
        .step-controls,
        .step-button,
        .array-element.swapping {
            display: none;
        }
        .template-selector {
            margin: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: calc(100% - 40px);
        }
        select {
            width: 100%;
            padding: 8px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
        }
        .array-controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .step-button {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .step-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .execution-flow {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
        }
        .stack-frame {
            border: 2px solid #2196F3;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background: #f8f9fa;
            position: relative;
        }
        .frame-title {
            background: #2196F3;
            color: white;
            padding: 5px 10px;
            margin: -10px -10px 10px -10px;
            border-radius: 2px 2px 0 0;
        }
        .arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 15px solid #2196F3;
            left: 50%;
            transform: translateX(-50%);
            margin: 5px 0;
        }
        .node-visited {
            fill: #ff5722 !important;
            transition: fill 0.3s ease;
        }
        .edge-visited {
            stroke: #ff5722 !important;
            stroke-width: 3px !important;
            transition: all 0.3s ease;
        }
        .node-current {
            fill: #4CAF50 !important;
            transform: scale(1.2);
            transition: all 0.3s ease;
        }
        .node-to-visit {
            fill: #2196F3 !important;
        }
        .node-visited circle {
            fill: #ff5722 !important;
            transition: all 0.3s ease;
        }
        .node-current circle {
            fill: #4CAF50 !important;
            transform: scale(1.2);
            transform-origin: center;
            transition: all 0.3s ease;
        }
        .node-to-visit circle {
            fill: #2196F3 !important;
            transition: all 0.3s ease;
        }
        .edge-visited {
            stroke: #ff5722 !important;
            stroke-width: 3px !important;
            transition: all 0.3s ease;
        }
        .execution-diagram {
            margin-top: 20px;
            padding: 20px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .frame-variables {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 15px;
            padding: 5px;
        }
        .variable-name {
            font-weight: bold;
            color: #333;
        }
        .variable-value {
            font-family: monospace;
            color: #4CAF50;
        }
        .return-value {
            color: #f44336;
            font-weight: bold;
        }
        .recursive-tree {
            margin: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .recursive-call {
            margin-left: 20px;
            padding: 8px;
            border-left: 2px solid #2196F3;
            position: relative;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.3s ease;
        }
        .recursive-call.active {
            opacity: 1;
            transform: translateX(0);
        }
        .recursive-call::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 12px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #2196F3;
        }
        .recursive-result {
            color: #4CAF50;
            font-weight: bold;
        }
        .recursive-args {
            color: #666;
            font-style: italic;
        }
        .binary-tree {
            display: flex;
            justify-content: center;
            padding: 20px;
        }
        .tree-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .node-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #69b3a2;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: all 0.3s ease;
        }
        .node-circle.current {
            background: #4CAF50;
            transform: scale(1.2);
        }
        .tree-edge {
            position: absolute;
            background: #999;
            height: 2px;
            transition: all 0.3s ease;
        }
        .performance-panel {
            position: fixed;
            top: 0;
            right: 0;
            background: white;
            padding: 15px;
            border-radius: 0 0 0 4px;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.1);
            transition: height 0.3s ease;
            overflow: hidden;
        }
        .minimize-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 5px;
            font-size: 20px;
            line-height: 1;
        }
        .minimize-button:hover {
            color: #333;
        }
        .performance-panel.minimized {
            height: 40px !important;
        }
        .performance-panel.minimized #profileData,
        .performance-panel.minimized #executionTime {
            display: none;
        }
        .execution-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .execution-step {
            font-family: monospace;
            color: #666;
            flex-grow: 1;
            text-align: center;
        }
        .nav-button {
            padding: 8px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-button:hover {
            background: #1976D2;
        }
        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .speed-control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            width: calc(100% - 30px);
        }
        .speed-control input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }
        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .speed-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        .speed-label {
            min-width: 120px;
            font-weight: bold;
        }
        .speed-value {
            min-width: 80px;
            text-align: right;
            color: #4CAF50;
        }
        .speed-preset {
            padding: 5px 10px;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            background: white;
            color: #4CAF50;
            cursor: pointer;
            transition: all 0.2s;
        }
        .speed-preset:hover {
            background: #4CAF50;
            color: white;
        }
        .loop-highlight {
            background-color: rgba(255, 193, 7, 0.2);
            border-left: 3px solid #ffc107;
        }
        .function-highlight {
            background-color: rgba(33, 150, 243, 0.2);
            border-left: 3px solid #2196f3;
        }
        .nested-highlight {
            border-left-width: 6px;
        }
    </style>
</head>
<body>
    <h1>Data Structure Visualizer</h1>
    <div class="template-selector">
        <select id="algorithmSelect" onchange="loadAlgorithm()">
            <option value="">Select an Algorithm</option>
            <option value="bfs">1. Breadth-First Search (BFS)</option>
            <option value="dfs">2. Depth-First Search (DFS)</option>
            <option value="bubble">3. Bubble Sort</option>
            <option value="insertion">4. Insertion Sort</option>
            <option value="binary">5. Binary Search</option>
            <option value="fibonacci">6. Fibonacci Sequence</option>
            <option value="factorial">7. Factorial</option>
            <option value="knapsack">8. 0/1 Knapsack</option>
            <option value="example">Example Code (Queue & 2D Array)</option>
        </select>
    </div>
    <div class="editor-container">
        <button onclick="runCode()">Run Code</button>
        <textarea id="editor"></textarea>
    </div>
    <div id="output"></div>
    <div id="visualization-area"></div>
    <div class="execution-flow">
        <h3>Execution Flow</h3>
        <div class="execution-controls">
            <button class="nav-button" onclick="previousExecution()" id="prevExecution">← Previous</button>
            <span class="execution-step" id="executionStep">Step 0/0</span>
            <button class="nav-button" onclick="nextExecution()" id="nextExecution">Next →</button>
        </div>
        <div id="stackFrames"></div>
    </div>
    <div id="output"></div>
    <div class="performance-panel" id="performancePanel" style="display: none">
        <button class="minimize-button" onclick="togglePerformancePanel()">−</button>
        <h3>Performance Stats</h3>
        <div id="executionTime"></div>
        <div id="profileData"></div>
    </div>
    <div class="control-panel">
        <div class="speed-control">
            <span class="speed-label">Animation Speed:</span>
            <input type="range" id="animationSpeed" min="0.1" max="2" step="0.1" value="0.5">
            <span class="speed-value" id="speedValue">0.5s</span>
            <button class="speed-preset" onclick="setSpeed(0.1)">Fast</button>
            <button class="speed-preset" onclick="setSpeed(0.5)">Normal</button>
            <button class="speed-preset" onclick="setSpeed(1.0)">Slow</button>
        </div>
    </div>
    <script>
        const editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
            mode: "python",
            theme: "monokai",
            lineNumbers: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            autoCloseBrackets: true,
            matchBrackets: true,
            lineWrapping: true
        });
        const algorithmTemplates = {
            example: `# Example code
from collections import deque
# Create a queue
queue = deque([1, 2, 3, 4, 5])
queue.append(6)
queue.popleft()
# Create a 2D array
grid = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
grid[1][1] = 0`,
            bfs: `# Breadth-First Search (BFS)
def bfs(graph, start_node):
    visited = set()
    queue = [start_node]
    while queue:
        node = queue.pop(0)
        if node not in visited:
            visited.add(node)
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    queue.append(neighbor)
    return visited
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
start_node = 'A'
result = bfs(graph, start_node)
print("BFS Traversal:", result)`,
            dfs: `# Depth-First Search (DFS)
def dfs(graph, node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    for neighbor in graph.get(node, []):
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
start_node = 'A'
result = dfs(graph, start_node)
print("DFS Traversal:", result)`,
            bubble: `# Bubble Sort
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if (arr[j] > arr[j + 1]):
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
arr = [64, 34, 25, 12, 22, 11, 90]
result = bubble_sort(arr)
print("Sorted Array:", result)`,
            insertion: `# Insertion Sort
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
arr = [12, 11, 13, 5, 6]
result = insertion_sort(arr)
print("Sorted Array:", result)`,
            binary: `# Binary Search
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) 
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
result = binary_search(arr, target)
print(f"Element found at index: {result}" if result != -1 else "Element not found")`,
            fibonacci: `# Fibonacci Sequence (Recursive)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
n = 10
fib_sequence = [fibonacci(i) for i in range(n)]
print("Fibonacci Sequence:", fib_sequence)`,
            factorial: `# Factorial (Recursive)
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
n = 5
result = factorial(n)
print(f"Factorial of {n}:", result)`,
            knapsack: `# 0/1 Knapsack (Tabulation)
def knapsack_tab(weights, values, W, n):
    table = [[0] * (W + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                table[i][w] = 0
            elif weights[i-1] <= w:
                table[i][w] = max(values[i-1] + table[i-1][w-weights[i-1]], table[i-1][w])
            else:
                table[i][w] = table[i-1][w]
    return table[n][W]
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
W = 5  # Weight limit
n = len(weights)
print("Maximum value:", knapsack_tab(weights, values, W, n))`
        };
        function loadAlgorithm() {
            const selected = document.getElementById('algorithmSelect').value;
            if (selected && algorithmTemplates[selected]) {
                editor.setValue(algorithmTemplates[selected]);
            }
        }
        editor.setValue(algorithmTemplates.example);
        const socket = io();
        let visualizationState = new Map();
        function runCode() {
            activeLoops.forEach(marker => marker.clear());
            activeLoops.clear();
            loopMarkers.clear();
            executionSteps = [];
            currentStep = -1;
            updateExecutionControls();
            document.getElementById('stackFrames').innerHTML = '';
            document.getElementById('output').innerHTML = '';
            document.getElementById('visualization-area').innerHTML = '';
            visualizationState.clear();
            socket.emit('run_code', { code: editor.getValue() });
        }
        function createArrayVisualization(data, container) {
            const arrayContainer = document.createElement('div');
            arrayContainer.className = 'array-visualization';
            if (data.history && data.history.length > 1) {
                const controls = document.createElement('div');
                controls.className = 'array-controls';
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '←';
                prevBtn.className = 'step-button';
                const nextBtn = document.createElement('button');
                nextBtn.textContent = '→';
                nextBtn.className = 'step-button';
                const stepCounter = document.createElement('span');
                stepCounter.textContent = `Step 1/${data.history.length}`;
                let currentStep = 0;
                prevBtn.onclick = () => {
                    if (currentStep > 0) {
                        currentStep--;
                        updateArrayView(data.history[currentStep]);
                        stepCounter.textContent = `Step ${currentStep + 1}/${data.history.length}`;
                        nextBtn.disabled = false;
                        prevBtn.disabled = currentStep === 0;
                    }
                };
                nextBtn.onclick = () => {
                    if (currentStep < data.history.length - 1) {
                        currentStep++;
                        updateArrayView(data.history[currentStep]);
                        stepCounter.textContent = `Step ${currentStep + 1}/${data.history.length}`;
                        prevBtn.disabled = false;
                        nextBtn.disabled = currentStep === data.history.length - 1;
                    }
                };
                controls.appendChild(prevBtn);
                controls.appendChild(stepCounter);
                controls.appendChild(nextBtn);
                container.appendChild(controls);
            }
            function updateArrayView(values) {
                arrayContainer.innerHTML = '';
                values.forEach((value, index) => {
                    const element = document.createElement('div');
                    element.className = 'array-element';
                    element.textContent = value;
                    const previousValue = visualizationState.get(`${data.name}_${index}`);
                    if (previousValue !== undefined && previousValue !== value) {
                        element.classList.add('changed');
                    }
                    arrayContainer.appendChild(element);
                    visualizationState.set(`${data.name}_${index}`, value);
                });
            }
            updateArrayView(data.value);
            container.appendChild(arrayContainer);
        }
        function createGraphVisualization(data, container) {
            const graphContainer = document.createElement('div');
            graphContainer.className = 'graph-visualization';
            container.appendChild(graphContainer);
            const width = graphContainer.offsetWidth;
            const height = 300;
            const svg = d3.select(graphContainer)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            const links = [];
            Object.entries(data.value).forEach(([source, targets]) => {
                if (Array.isArray(targets)) {
                    targets.forEach(target => {
                        links.push({
                            id: `${source}-${target}`,
                            source: source,
                            target: target.toString()
                        });
                    });
                }
            });
            const nodes = Object.keys(data.value).map(key => ({
                id: key,
                visited: false,
                current: false
            }));
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2));
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '-0 -5 10 10')
                .attr('refX', 20)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .append('path')
                .attr('d', 'M 0,-5 L 10,0 L 0,5')
                .attr('fill', '#999');
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('id', d => d.id)
                .style('stroke', '#999')
                .style('stroke-width', 2)
                .attr('marker-end', 'url(#arrowhead)');
            const nodeGroup = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g');
            nodeGroup.append('circle')
                .attr('r', 15)
                .style('fill', '#69b3a2')
                .attr('id', d => `node-${d.id}`);
            nodeGroup.append('text')
                .text(d => d.id)
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('pointer-events', 'none');
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                nodeGroup
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
            let visitedNodes = new Set();
            let visitedEdges = new Set();
            socket.on('highlight_visited', (data) => {
                nodeGroup
                    .classed('node-visited', false)
                    .classed('node-current', false)
                    .classed('node-to-visit', false);
                link.classed('edge-visited', false);
                data.nodes.forEach(nodeId => {
                    nodeGroup
                        .filter(d => d.id === nodeId)
                        .classed('node-visited', true);
                });
                if (data.to_visit) {
                    data.to_visit.forEach(nodeId => {
                        nodeGroup
                            .filter(d => d.id === nodeId)
                            .classed('node-to-visit', true);
                    });
                }
                if (data.current) {
                    nodeGroup
                        .filter(d => d.id === data.current)
                        .classed('node-current', true)
                        .classed('node-visited', false)
                        .classed('node-to-visit', false)
                        .raise(); 
                }
                data.edges.forEach(edgeId => {
                    link
                        .filter(d => d.id === edgeId)
                        .classed('edge-visited', true)
                        .raise(); 
                });
            });
            return () => {
                socket.off('highlight_visited');
            };
        }
        function createQueueVisualization(data, container) {
            const queueContainer = document.createElement('div');
            queueContainer.className = 'array-visualization';
            data.value.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'queue-element';
                element.textContent = value;
                queueContainer.appendChild(element);
            });
            container.appendChild(queueContainer);
        }
        function create2DArrayVisualization(data, container) {
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';
            data.value.forEach((row, i) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'grid-row';
                row.forEach((cell, j) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'grid-cell';
                    cellDiv.textContent = cell;
                    const previousValue = visualizationState.get(`${data.name}_${i}_${j}`);
                    if (previousValue !== undefined && previousValue !== cell) {
                        cellDiv.style.backgroundColor = '#ffcdd2';
                    }
                    visualizationState.set(`${data.name}_${i}_${j}`, cell);
                    rowDiv.appendChild(cellDiv);
                });
                gridContainer.appendChild(rowDiv);
            });
            container.appendChild(gridContainer);
        }
        function createBinaryTreeVisualization(data, container) {
            const treeContainer = document.createElement('div');
            treeContainer.className = 'binary-tree';
            function createNode(nodeData, x, y, level) {
                if (!nodeData) return null;
                const node = document.createElement('div');
                node.className = 'tree-node';
                node.style.transform = `translate(${x}px, ${y}px)`;
                const circle = document.createElement('div');
                circle.className = 'node-circle';
                circle.textContent = nodeData.value;
                if (data.current && data.current.value === nodeData.value) {
                    circle.classList.add('current');
                }
                node.appendChild(circle);
                return node;
            }
            function renderTree(root, container) {
                const spacing = 60;
                const levelHeight = 80;
                const queue = [{node: root, x: 0, y: 0, level: 0}];
                while (queue.length > 0) {
                    const {node, x, y, level} = queue.shift();
                    const renderedNode = createNode(node, x, y, level);
                    if (renderedNode) {
                        container.appendChild(renderedNode);
                        if (node.left) {
                            queue.push({
                                node: node.left,
                                x: x - spacing / (level + 1),
                                y: y + levelHeight,
                                level: level + 1
                            });
                        }
                        if (node.right) {
                            queue.push({
                                node: node.right,
                                x: x + spacing / (level + 1),
                                y: y + levelHeight,
                                level: level + 1
                            });
                        }
                    }
                }
            }
            renderTree(data.data, treeContainer);
            container.appendChild(treeContainer);
        }
        socket.on('performance_stats', function(stats) {
            const panel = document.getElementById('performancePanel');
            panel.style.display = 'block';
            panel.classList.remove('minimized');  
            panel.querySelector('.minimize-button').textContent = '−';
            document.getElementById('executionTime').textContent = 
                `Execution Time: ${stats.execution_time.toFixed(3)}s`;
            const profileData = document.getElementById('profileData');
            profileData.innerHTML = `<pre>${stats.profile}</pre>`;
        });
        socket.on('update_visualization', (data) => {
            if (data.type === 'clear_visualization') {
                visualizationState.clear();
            }
            const container = document.getElementById('visualization-area');
            if (data.type === 'output') {
                const outputDiv = document.getElementById('output');
                outputDiv.textContent += data.value + '\n';
            }
            else if (data.type === 'error') {
                const outputDiv = document.getElementById('output');
                outputDiv.innerHTML += `<span style="color: red">${data.message}</span>\n`;
            }
            else if (data.type === 'data_structure') {
                container.innerHTML = ''; 
                data.data.forEach((visualData) => {
                    const label = document.createElement('div');
                    label.textContent = `${visualData.name}:`;
                    container.appendChild(label);
                    if (visualData.type === 'array') {
                        createArrayVisualization(visualData, container);
                    } else if (visualData.type === 'graph') {
                        createGraphVisualization(visualData, container);
                    } else if (visualData.type === 'queue') {
                        createQueueVisualization(visualData, container);
                    } else if (visualData.type === '2d_array') {
                        create2DArrayVisualization(visualData, container);
                    } else if (visualData.type === 'binary_tree') {
                        createBinaryTreeVisualization(visualData, container);
                    }
                });
            }
        });
        let executionSteps = [];
        let currentStep = -1;
        function updateExecutionControls() {
            const prevBtn = document.getElementById('prevExecution');
            const nextBtn = document.getElementById('nextExecution');
            const stepDisplay = document.getElementById('executionStep');
            prevBtn.disabled = currentStep <= 0;
            nextBtn.disabled = currentStep >= executionSteps.length - 1;
            stepDisplay.textContent = `Step ${currentStep + 1}/${executionSteps.length}`;
        }
        function previousExecution() {
            if (currentStep > 0) {
                currentStep--;
                updateExecutionFlow(executionSteps[currentStep]);
                updateExecutionControls();
            }
        }
        function nextExecution() {
            if (currentStep < executionSteps.length - 1) {
                currentStep++;
                updateExecutionFlow(executionSteps[currentStep]);
                updateExecutionControls();
            }
        }
        socket.on('code_step', function(data) {
            executionSteps.push(data);
            currentStep = executionSteps.length - 1;
            updateExecutionFlow(data);
            updateExecutionControls();
        });
        function updateExecutionFlow(data) {
            const diagram = document.getElementById('stackFrames');
            diagram.innerHTML = '';
            const globalFrame = createStackFrame('Global Frame');
            diagram.appendChild(globalFrame);
            if (data.variables) {
                for (let [name, info] of Object.entries(data.variables)) {
                    if (data.function && data.function !== '<module>') {
                        const functionFrame = createStackFrame(data.function);
                        const arrow = document.createElement('div');
                        arrow.className = 'arrow';
                        diagram.appendChild(arrow);
                        diagram.appendChild(functionFrame);
                        addVariableToFrame(functionFrame, name, info);
                    } else {
                        addVariableToFrame(globalFrame, name, info);
                    }
                }
            }
            editor.getAllMarks().forEach(mark => mark.clear());
            const line = data.line - 1;
            const lineContent = editor.getLine(line);
            if (lineContent) {
                const marker = editor.markText(
                    {line: line, ch: 0},
                    {line: line, ch: lineContent.length},
                    {className: 'current-line'}
                );
                editor.scrollIntoView({line: line, ch: 0}, 100);
            }
        }
        function createStackFrame(title) {
            const frame = document.createElement('div');
            frame.className = 'stack-frame';
            frame.style.opacity = '0';
            frame.style.transform = 'translateY(20px)';
            const titleDiv = document.createElement('div');
            titleDiv.className = 'frame-title';
            titleDiv.textContent = title;
            const varsDiv = document.createElement('div');
            varsDiv.className = 'frame-variables';
            frame.appendChild(titleDiv);
            frame.appendChild(varsDiv);
            requestAnimationFrame(() => {
                frame.style.transition = 'all 0.3s ease';
                frame.style.opacity = '1';
                frame.style.transform = 'translateY(0)';
            });
            return frame;
        }
        function addVariableToFrame(frame, name, info) {
            const varsDiv = frame.querySelector('.frame-variables');
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.opacity = '0';
            const nameSpan = document.createElement('span');
            nameSpan.className = 'variable-name';
            nameSpan.textContent = name;
            const valueSpan = document.createElement('span');
            valueSpan.className = 'variable-value';
            valueSpan.textContent = formatValue(info);
            row.appendChild(nameSpan);
            row.appendChild(valueSpan);
            varsDiv.appendChild(row);
            requestAnimationFrame(() => {
                row.style.transition = 'all 0.3s ease';
                row.style.opacity = '1';
            });
        }
        function formatValue(info) {
            if (info.type === 'list' || info.type === 'tuple') {
                return `${info.type}[${info.value.join(', ')}]`;
            } else if (info.type === 'dict') {
                const entries = Object.entries(info.value)
                    .map(([k, v]) => `${k}: ${v}`).join(', ');
                return `{${entries}}`;
            }
            return info.value;
        }
        function stepForward() {
            if (currentStep < executionSteps.length - 1) {
                currentStep++;
                updateExecutionFlow(executionSteps[currentStep]);
            }
        }
        function stepBackward() {
            if (currentStep > 0) {
                currentStep--;
                updateExecutionFlow(executionSteps[currentStep]);
            }
        }
        socket.on('recursive_call', function(data) {
            const callInfo = data.data;
            const treeContainer = document.querySelector('.recursive-tree') || 
                                createRecursiveTree();
            if (data.type === 'enter') {
                const callElement = document.createElement('div');
                callElement.className = 'recursive-call';
                callElement.id = `call-${callInfo.level}-${callInfo.function}`;
                callElement.innerHTML = `
                    <div class="recursive-args">
                        ${callInfo.function}(${formatArgs(callInfo.args)})
                    </div>
                `;
                const parentLevel = callInfo.level - 1;
                const parent = document.querySelector(`#call-${parentLevel}-${callInfo.function}`) 
                            || treeContainer;
                parent.appendChild(callElement);
                requestAnimationFrame(() => {
                    callElement.classList.add('active');
                });
            } else if (data.type === 'exit') {
                const callElement = document.querySelector(
                    `#call-${callInfo.level}-${callInfo.function}`
                );
                if (callElement) {
                    callElement.style.borderColor = '#4CAF50';
                }
            }
        });
        function createRecursiveTree() {
            const container = document.createElement('div');
            container.className = 'recursive-tree';
            container.innerHTML = '<h3>Recursion Tree</h3>';
            document.body.appendChild(container);
            return container;
        }
        function formatArgs(args) {
            return Object.entries(args)
                .map(([k, v]) => `${k}=${v}`)
                .join(', ');
        }
        function togglePerformancePanel() {
            const panel = document.getElementById('performancePanel');
            const btn = panel.querySelector('.minimize-button');
            if (panel.classList.toggle('minimized')) {
                btn.textContent = '+';
            } else {
                btn.textContent = '−';
            }
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') {
                previousExecution();
            } else if (e.key === 'ArrowRight') {
                nextExecution();
            }
        });
        function setSpeed(speed) {
            const slider = document.getElementById('animationSpeed');
            slider.value = speed;
            updateSpeed(speed);
        }
        function updateSpeed(speed) {
            document.getElementById('speedValue').textContent = speed.toFixed(1) + 's';
            socket.emit('set_animation_speed', { speed });
        }
        document.getElementById('animationSpeed').addEventListener('input', function(e) {
            const speed = parseFloat(e.target.value);
            updateSpeed(speed);
        });
        document.addEventListener('keydown', function(e) {
            const slider = document.getElementById('animationSpeed');
            const currentSpeed = parseFloat(slider.value);
            if (e.key === '[') {
                setSpeed(Math.max(0.1, currentSpeed - 0.1));
            } else if (e.key === ']') {
                setSpeed(Math.min(2.0, currentSpeed + 0.1));
            }
        });
        let activeLoops = new Map();
        let loopMarkers = new Map();
        socket.on('loop_update', function(data) {
            const doc = editor.getDoc();
            if (data.is_enter) {
                const line = data.line - 1;
                const lineText = editor.getLine(line);
                let endLine = line;
                let level = 0;
                const indent = lineText.match(/^\s*/)[0].length;
                for (let i = line + 1; i < doc.lineCount(); i++) {
                    const currLine = editor.getLine(i);
                    const currIndent = currLine.match(/^\s*/)[0].length;
                    if (currIndent === indent) {
                        endLine = i;
                        break;
                    }
                }
                const marker = editor.markText(
                    {line: line, ch: 0},
                    {line: endLine, ch: editor.getLine(endLine).length},
                    {
                        className: `loop-highlight${activeLoops.size > 0 ? ' nested-highlight' : ''}`,
                        css: `opacity: ${1 - activeLoops.size * 0.2}`
                    }
                );
                activeLoops.set(data.id, marker);
                loopMarkers.set(data.id, {line, endLine});
            } else {
                const marker = activeLoops.get(data.id);
                if (marker) {
                    marker.clear();
                    activeLoops.delete(data.id);
                    loopMarkers.delete(data.id);
                }
            }
        });
    </script>
</body>
</html>